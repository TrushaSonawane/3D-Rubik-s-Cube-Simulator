<!--
Author: Trusha Sonawane
Date: November 04, 2025
Title: 3D Rubik's Cube Simulator 
---->




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rubik's Cube Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Orbit Controls for camera movement -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            text-align: center;
            color: #ffffff;
            z-index: 10;
            background: rgba(17, 24, 39, 0.7); /* Darker, sleek header */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        canvas {
            display: block;
            touch-action: none; 
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="info">
        <h1 class="text-2xl font-black text-gray-100 mb-1">Rubik's Cube Simulator</h1>
        <p class="text-sm mb-4 font-normal text-gray-300">
            Click and drag/swipe a face to twist that layer. Click the background to rotate the view.
        </p>
        <div class="flex justify-center">
            <button id="jumble_button" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold rounded-xl shadow-lg hover:from-blue-600 hover:to-indigo-700 transition duration-150 transform hover:scale-105">
                SCRAMBLE
            </button>
        </div>
    </div>

    <div id="container"></div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let raycaster;
        let mouse = new THREE.Vector2();
        let cubies = [];

        // State Variables
        let isRotating = false;
        let activeRotation = null;
        
        // Drag Interaction Variables
        let dragData = null;
        const DRAG_THRESHOLD = 50; 

        // Configuration
        const CUBE_SIZE = 1;
        const SPACING = 0.1; // Increased spacing for better visibility
        const COLORS = {
            R: 0xFF0000, // Red (Front, Z+)
            O: 0xFF8C00, // Orange (Back, Z-)
            G: 0x00FF00, // Green (Top, Y+)
            B: 0x0000FF, // Blue (Bottom, Y-)
            Y: 0xFFFF00, // Yellow (Left, X-)
            W: 0xFFFFFF, // White (Right, X+)
            D: 0x111111  // Dark/Internal (Internal/Gap color)
        };
        const MOVES = [
            { axis: 'x', index: 1, direction: 1 }, { axis: 'x', index: 1, direction: -1 }, 
            { axis: 'x', index: -1, direction: 1 }, { axis: 'x', index: -1, direction: -1 },
            { axis: 'x', index: 0, direction: 1 }, { axis: 'x', index: 0, direction: -1 }, // M-moves (middle slice)
            { axis: 'y', index: 1, direction: 1 }, { axis: 'y', index: 1, direction: -1 }, 
            { axis: 'y', index: -1, direction: 1 }, { axis: 'y', index: -1, direction: -1 },
            { axis: 'y', index: 0, direction: 1 }, { axis: 'y', index: 0, direction: -1 }, // E-moves (equator slice)
            { axis: 'z', index: 1, direction: 1 }, { axis: 'z', index: 1, direction: -1 }, 
            { axis: 'z', index: -1, direction: 1 }, { axis: 'z', index: -1, direction: -1 },
            { axis: 'z', index: 0, direction: 1 }, { axis: 'z', index: 0, direction: -1 } // S-moves (standing slice)
        ];

        // --- Cube Core Logic ---

        function createCubieMaterials(x, y, z) {
            let faces = new Array(6).fill(COLORS.D);
            if (x === 1) faces[0] = COLORS.W; // Right (X+)
            if (x === -1) faces[1] = COLORS.Y; // Left (X-)
            if (y === 1) faces[2] = COLORS.G; // Top (Y+)
            if (y === -1) faces[3] = COLORS.B; // Bottom (Y-)
            if (z === 1) faces[4] = COLORS.R; // Front (Z+)
            if (z === -1) faces[5] = COLORS.O; // Back (Z-)
            
            return faces.map(color => new THREE.MeshBasicMaterial({ color: color, side: THREE.FrontSide }));
        }

        function getCoordinateIndex(coord) {
            // Converts cubie world position (e.g., 1.1) into an index (-1, 0, or 1)
            return Math.round(coord / (CUBE_SIZE + SPACING));
        }

        function getCubiesInLayer(axis, layerIndex) {
            return cubies.filter(cubie => {
                let index;
                if (axis === 'x') index = getCoordinateIndex(cubie.position.x);
                else if (axis === 'y') index = getCoordinateIndex(cubie.position.y);
                else if (axis === 'z') index = getCoordinateIndex(cubie.position.z);
                return index === layerIndex;
            });
        }

        /**
         * Starts an animated 90-degree face rotation.
         */
        function startRotation(axis, layerIndex, direction, isJumble = false) {
            if (isRotating) return;
            
            isRotating = true;
            controls.enabled = false;

            const layer = getCubiesInLayer(axis, layerIndex);
            const pivot = new THREE.Object3D();
            scene.add(pivot);

            layer.forEach(cubie => {
                pivot.attach(cubie);
            });

            const rotationAngle = direction * Math.PI / 2;
            
            activeRotation = {
                axis,
                layerIndex,
                direction,
                targetRotation: rotationAngle,
                cubies: layer,
                pivot: pivot,
                currentRotation: 0,
                rotationSpeed: Math.PI / 16, 
                isJumble: isJumble
            };
        }

        /*
        Executes a random sequence of moves to scramble the cube.
         */
        function jumbleCube() {
            if (isRotating) return;
            
            document.getElementById('jumble_button').disabled = true;
            controls.enabled = false;

            const JUMBLE_LENGTH = 25; 
            const JUMBLE_DELAY_MS = 150; 

            let moveIndex = 0;

            const jumbleNextMove = () => {
                if (isRotating) {
                     // Wait for current rotation to finish
                     setTimeout(jumbleNextMove, 50); 
                     return;
                }
                
                if (moveIndex >= JUMBLE_LENGTH) {
                    // Jumble finished
                    controls.enabled = true; 
                    document.getElementById('jumble_button').disabled = false;
                    return;
                }

                const randomMove = MOVES[Math.floor(Math.random() * MOVES.length)]; 
                startRotation(randomMove.axis, randomMove.index, randomMove.direction, true);
                
                moveIndex++;
                setTimeout(jumbleNextMove, JUMBLE_DELAY_MS);
            };

            jumbleNextMove();
        }

        // --- Drag/Swipe Interaction Handlers ---

        function getIntersection(event) {
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            return raycaster.intersectObjects(cubies, false);
        }

        function onPointerDown(event) {
            if (isRotating) return;

            // Only register mouse down if the target is the canvas
            if (event.target !== renderer.domElement) return;

            const intersects = getIntersection(event);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const cubie = intersect.object;

                // Store the cubie's index coordinates
                const cubieX = getCoordinateIndex(cubie.position.x);
                const cubieY = getCoordinateIndex(cubie.position.y);
                const cubieZ = getCoordinateIndex(cubie.position.z);
                
                // Store the local normal of the clicked face
                const localNormal = intersect.face.normal;

                dragData = {
                    startClientX: event.clientX,
                    startClientY: event.clientY,
                    cubieX, cubieY, cubieZ,
                    localNormal // Local normal: [1, 0, 0] for a face on the +X side of its own bounding box
                };

                controls.enabled = false;
                renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            } else {
                controls.enabled = true;
            }
        }

        function onPointerMove(event) {
            // Placeholder to keep the move listener active and dragData available
        }

        function onPointerUp(event) {
            renderer.domElement.removeEventListener('pointermove', onPointerMove, false);
            
            if (!dragData) {
                if (!isRotating) controls.enabled = true;
                return;
            }

            const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
            const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;

            const dx = clientX - dragData.startClientX;
            const dy = clientY - dragData.startClientY;
            const totalDrag = Math.sqrt(dx * dx + dy * dy);

            if (totalDrag > DRAG_THRESHOLD) {
                
                let rotationAxis = null;
                let layerIndex = 0;
                let direction = 0;
                
                const { cubieX, cubieY, cubieZ, localNormal } = dragData;
                const absX = Math.abs(localNormal.x);
                const absY = Math.abs(localNormal.y);
                const absZ = Math.abs(localNormal.z);

                // Determine rotation axis based on the clicked face (localNormal) and swipe direction (dx/dy)
                // This logic is complex, determining the intended 90-degree twist
                if (absX > 0.9) { // Clicked on a face local to the X-axis (Right/Left)
                    if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe -> Z-rotation (F/B slices)
                        rotationAxis = 'z';
                        layerIndex = cubieZ;
                        direction = (dx > 0 ? -1 : 1) * localNormal.x; 
                    } else { // Vertical swipe -> Y-rotation (U/D slices)
                        rotationAxis = 'y';
                        layerIndex = cubieY;
                        direction = (dy < 0 ? 1 : -1); 
                    }
                } else if (absY > 0.9) { // Clicked on a face local to the Y-axis (Up/Down)
                    if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe -> Z-rotation (F/B slices)
                        rotationAxis = 'z';
                        layerIndex = cubieZ;
                        direction = (dx > 0 ? 1 : -1) * localNormal.y;
                    } else { // Vertical swipe -> X-rotation (R/L slices)
                        rotationAxis = 'x';
                        layerIndex = cubieX;
                        direction = (dy < 0 ? -1 : 1);
                    }
                } else if (absZ > 0.9) { // Clicked on a face local to the Z-axis (Front/Back)
                    if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe -> Y-rotation (U/D slices)
                        rotationAxis = 'y';
                        layerIndex = cubieY;
                        direction = (dx > 0 ? -1 : 1) * localNormal.z;
                    } else { // Vertical swipe -> X-rotation (R/L slices)
                        rotationAxis = 'x';
                        layerIndex = cubieX;
                        direction = (dy < 0 ? 1 : -1) * localNormal.z;
                    }
                }
                
                if (rotationAxis) {
                    startRotation(rotationAxis, layerIndex, direction);
                }
            }
            
            dragData = null;
            if (!isRotating) {
                controls.enabled = true;
            }
        }


        function updateRotation() {
            if (!isRotating || !activeRotation) return;

            const { axis, targetRotation, rotationSpeed, pivot } = activeRotation;
            const remainingRotation = targetRotation - activeRotation.currentRotation;
            
            let delta = Math.min(rotationSpeed, Math.abs(remainingRotation));
            if (remainingRotation < 0) delta *= -1; 

            if (axis === 'x') pivot.rotation.x += delta;
            else if (axis === 'y') pivot.rotation.y += delta;
            else if (axis === 'z') pivot.rotation.z += delta;

            activeRotation.currentRotation += delta;

            if (Math.abs(activeRotation.currentRotation - targetRotation) < 0.01) {
                
                // Finalize rotation and snap cubies back to the scene
                const finalRotation = targetRotation % (Math.PI * 2);
                if (axis === 'x') pivot.rotation.x = finalRotation;
                else if (axis === 'y') pivot.rotation.y = finalRotation;
                else if (axis === 'z') pivot.rotation.z = finalRotation;

                scene.remove(pivot);
                activeRotation.cubies.forEach(cubie => {
                    pivot.updateWorldMatrix(true, true);
                    cubie.applyMatrix4(pivot.matrix);
                    
                    // Recalculate and snap position to the grid after rotation
                    const offset = CUBE_SIZE + SPACING;
                    cubie.position.set(
                        Math.round(cubie.position.x / offset) * offset,
                        Math.round(cubie.position.y / offset) * offset,
                        Math.round(cubie.position.z / offset) * offset
                    );
                    scene.attach(cubie); 
                });

                pivot.geometry?.dispose();
                activeRotation = null;
                isRotating = false;
                
                if (!isRotating) {
                    controls.enabled = true;
                }
            }
        }

        // --- Core Setup & Loop ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.set(4, 4, 6);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            
            // Generate the 3x3x3 grid of cubies
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
                        const materials = createCubieMaterials(x, y, z);
                        const cubie = new THREE.Mesh(geometry, materials);

                        const offset = CUBE_SIZE + SPACING;
                        cubie.position.set(x * offset, y * offset, z * offset);
                        
                        scene.add(cubie);
                        cubies.push(cubie);
                    }
                }
            }

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            window.addEventListener('resize', onWindowResize, false);
            
            // Set up pointer event listeners
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            
            document.getElementById('jumble_button').addEventListener('click', jumbleCube, false);

            raycaster = new THREE.Raycaster();
            
            controls.enabled = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateRotation();
            renderer.render(scene, camera);
        }

        window.onload = function () {
            init();
            animate();
        }

    </script>
</body>
</html>
